[1.恒阳数据笔试总结](#恒阳数据)

----------
## 恒阳数据
1.在一个线程中使用sleep（1000）方法，将使该线程在多少时间后获得CPU控制权(假设睡眠过程中不会有其他事件唤醒该线程)？
	
	答：大于等于1000秒	
	分析：sleep方法，使当前线程进入睡眠状态，并不会释放锁，但会让出CPU，休眠时间结束后，当前线程是可运行状态，因此是大于等于1000秒，而不是等于1000秒
	补充：sleep与wait的区别
	1.sleep是Thread类中的方法，wait是Object类中的方法	                             
	2.执行sleep不会使线程让出CPU，而执行wait会使当前线程让出CPU进入等待池，等待其他线程notify(唤醒)
	3.sleep(1000),1000s后当前线程进去Runnable状态，wait(1000),1000s后线程进去可运行状态。
2.Servlet生命周期中只会调用一次的方法?

	在servlet的整个生命周期中，servlet的初始化和销毁只会发生一次。其中init方法在servlet初次创建时被调用，之后处理每个用户的请求时，则不再调用这个方法。因此，init()方法主要用于一次性的初始化操作。比如创建或载入在servlet生命周期中要用到的一些数据（如果有的话），或者执行某些一次性的计算（如果需要的话）等。同样，在服务器移除或销毁servlet的实例之前，会调用servlet的destroy方法，从而使得servlet有机会关闭数据库连接（如果需要的话），停止后台运行的线程（如果需要的话）或者执行一些其它的清理操作（如果需要的话）等。 
3.局部内部类是否可以i访问非final变量？

	答：不可以	分析：因为局部变量会在方法调用完毕后立刻消失，而内部类对象的生命周期和其他对象的生命周期一样：当没有引用指向内存地址时，通过垃圾回收机制回收，所以如果局部局部内部类的成员不用final修饰的话，很可能出现方法已经已经调用完毕，内部类还没有被垃圾回收机制收回，定义为final后，编译器会把匿名内部类对象要访问的所有final类型局部变量，都拷贝一份作为该对象的成员变量。这样，即使栈中局部变量已经死亡，匿名内部类对象照样可以拿到该局部变量的值，因为它自己拷贝了一份，且与原局部变量的值始终保持一致
4.Character流与Byte流的区别？

	答：Character流是字符读写，Byte流是字节读写
	补充：
	Java的流操作分为字节流和字符流两种。字节流与字符流主要的区别是他们的的处理方式
	字节流是最基本的，所有的InputStream和OutputStream的子类都是，主要用在处理二进制数据，它是按字节来处理的。但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化，这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联。
	在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的。
	字节流---->字符流
	字节流转化为字符流，实际上就是byte[]转化为String时，
	public String(byte bytes[], String charsetName)
	有一个关键的参数字符集编码，通常我们都省略了，那系统就用操作系统的lang
	字符流---->字节流
	字符流转化为字节流，实际上是String转化为byte[]时，byte[] String.getBytes(String charsetName)也是一样的道理至于java.io中还出现了许多其他的流，按主要是为了提高性能和使用方便，如BufferedInputStream,PipedInputStream等
	常识：
	对于GBK编码标准，英文占用1个字节，中文占用2个字节
	对于UTF-8编码标准，英文占用1个字节，中文占用3个字节
	对于Unicode编码标准，英文中文都是2个字节。这也是为什么叫做unicode
5.静态代码块可以有多个吗？
	
	答：可以，会按照编写的顺序从上到下依次执行
	补充：构造代码块、静态代码块、局部代码块	
	1.构造代码块
	定义：直接在类中定义且没有加static关键字的代码块称为{}构造代码;
	作用：给对象统一初始化数据	说明：通过反编译工具可以发现，编译后构造代码块中的语句会在作为构造器中开头的语句
	2.局部代码块
	定义：在函数中的代码块
	作用：在方法中，如果要缩短变量生命周期可以使用
	3.静态代码块
	定义：在java中使用static关键字声明的代码块
	作用：用于初始化类，为类的属性初始化
	说明：每个静态代码块只执行一次，多个静态代码库编译后代码块中的内容会合并到一个静态代码块中，代码顺序按编写顺序排列。
6.接口可以修饰符
	
	答：只能是pulbic，缺省也为public
7.代码片段： 
	byte
	b1=1,b2=2,b3,b6; 
	final byte b4=4,b5=6; 
	b6=b4+b5; 
	b3=(b1+b2); 
	System.out.println(b3+b6);
	关于上面代码片段叙述正确的是（）
	正确答案: C 
	A.输出结果：13
	B.语句：b6=b4+b5编译出错
	C.语句：b3=b1+b2编译出错
	D.运行期抛出异常
	
	分析：java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。
8.代码片段
	int i1 =2;
	int i2 =3;
	int i3 =1;
	int i4 =3;
	System.out.println( (i1+i2)/(i3+i4));
  运行结果：1

    分析：int/int 结果还是int型








